---
phase: 02-linear-internal-write-actions
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - apps/server/src/tools/index.ts
  - apps/server/src/adapters/linearGraphql.ts
  - apps/server/src/services/approvalManager.ts
autonomous: true

must_haves:
  truths:
    - "Agent can propose creating, updating, and archiving Linear projects"
    - "Agent can propose adding/removing issues from cycles"
    - "Agent can propose creating and managing labels"
    - "Agent can propose bulk-updating multiple issues at once with a preview table showing all changes"
    - "Bulk operation shows each issue on its own row with title, current state, and new state"
    - "Bulk operations above 10 issues show a soft-cap warning but still allow the operation"
  artifacts:
    - path: "apps/server/src/tools/index.ts"
      provides: "Workflow and bulk write tool definitions and handlers"
      contains: "bulk_update_issues"
    - path: "apps/server/src/adapters/linearGraphql.ts"
      provides: "Project, cycle, and label mutation methods"
      contains: "createProject"
    - path: "apps/server/src/services/approvalManager.ts"
      provides: "Descriptions and summaries for workflow and bulk tools"
      contains: "bulk_update_issues"
  key_links:
    - from: "apps/server/src/tools/index.ts"
      to: "apps/server/src/adapters/linearGraphql.ts"
      via: "Workflow tool handlers call linear adapter mutations"
      pattern: "linear\\.(createProject|updateProject|addIssueToCycle|createLabel)"
    - from: "apps/server/src/tools/index.ts"
      to: "apps/server/src/tools/index.ts"
      via: "bulk_update_issues handler iterates and calls linear.updateIssue for each item"
      pattern: "linear\\.updateIssue"
---

<objective>
Register Linear workflow write tools (projects, cycles, labels) and a bulk_update_issues tool with table-style preview. Extend the Linear adapter with corresponding GraphQL mutations.

Purpose: Completes the Linear write action surface -- users can manage their full Linear workflow (projects, cycles, labels) and perform efficient bulk operations, all through the approval flow.
Output: Five additional write tools (manage_project, manage_cycle, manage_labels, bulk_update_issues) with Linear API integration.
</objective>

<execution_context>
@/Users/devondunn/.claude/get-shit-done/workflows/execute-plan.md
@/Users/devondunn/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-linear-internal-write-actions/02-01-SUMMARY.md

@apps/server/src/tools/index.ts
@apps/server/src/adapters/linearGraphql.ts
@apps/server/src/services/approvalManager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add workflow GraphQL mutations and register project/cycle/label tools</name>
  <files>
    apps/server/src/adapters/linearGraphql.ts
    apps/server/src/tools/index.ts
    apps/server/src/services/approvalManager.ts
  </files>
  <action>
**In linearGraphql.ts -- add mutation methods:**

1. `createProject(params: { teamIds: string[]; name: string; description?: string; state?: string }): Promise<{ id: string; name: string; url: string }>` -- Uses `projectCreate` mutation. Linear projects require teamIds (array).

2. `updateProject(projectId: string, input: { name?: string; description?: string; state?: string }): Promise<{ success: boolean }>` -- Uses `projectUpdate` mutation.

3. `addIssueToCycle(issueId: string, cycleId: string): Promise<{ success: boolean }>` -- Uses `issueUpdate` mutation with `{ cycleId }` input. Reuses the existing update pattern.

4. `removeIssueFromCycle(issueId: string): Promise<{ success: boolean }>` -- Uses `issueUpdate` with `{ cycleId: null }`.

5. `createLabel(teamId: string, name: string, color?: string): Promise<{ id: string; name: string }>` -- Uses `issueLabelCreate` mutation.

6. `listCyclesForTeam(teamKey: string): Promise<Array<{ id: string; name: string; number: number; startsAt: string; endsAt: string }>>` -- Extend existing listCycles to also return id/name for lookup purposes (or add a separate simplified method if listCycles format differs). This is needed for cycle name-to-ID resolution in tool handlers.

**In tools/index.ts -- add three tool definitions and handlers:**

7. **manage_project** tool:
   - Parameters: action (string, enum ["create", "update", "archive"]), projectName (string, required), description (string|null), newName (string|null -- for update/rename)
   - Metadata: requiresApproval: true, category: "action", actionCategory: "linear", descriptionForUser: "Create, update, or archive a Linear project"
   - generatePreview: Show action type, project name, description if provided
   - Handler: For "create" -- resolve teamId, call linear.createProject(). For "update" -- look up project by name from linear.listProjects(), call linear.updateProject(). For "archive" -- call updateProject with state: "canceled".
   - Return: { success: true, projectId, name, url } for create; { success: true, name } for update/archive.

8. **manage_cycle** tool:
   - Parameters: action (string, enum ["add_issue", "remove_issue"]), issueId (string, required), cycleName (string|null -- resolve to ID; if null, use active cycle)
   - Metadata: requiresApproval: true, category: "action", actionCategory: "linear", descriptionForUser: "Add or remove issues from a cycle"
   - generatePreview: Show action, issue identifier, cycle name
   - Handler: Resolve issueId (identifier to UUID if needed), resolve cycleName to cycleId via listCyclesForTeam or db.getActiveCycle(). Call addIssueToCycle or removeIssueFromCycle.
   - Return: { success: true, issueIdentifier, cycleName }

9. **manage_labels** tool:
   - Parameters: action (string, enum ["create", "add_to_issue", "remove_from_issue"]), labelName (string, required), issueId (string|null -- required for add/remove), color (string|null -- for create, hex color)
   - Metadata: requiresApproval: true, category: "action", actionCategory: "linear", descriptionForUser: "Create labels or add/remove labels from issues"
   - generatePreview: Show action, label name, issue identifier if applicable
   - Handler: For "create" -- resolve teamId, call linear.createLabel(). For "add_to_issue" -- get current issue labels, add the new one, call linear.updateIssue with combined labelIds. For "remove_from_issue" -- get current labels, remove the target, call linear.updateIssue.
   - Return: { success: true, labelName, issueIdentifier }

**In approvalManager.ts:**

10. Add buildDescription cases:
    - manage_project: "Create project: {name}" / "Update project: {name}" / "Archive project: {name}"
    - manage_cycle: "Add {identifier} to cycle {cycleName}" / "Remove {identifier} from cycle"
    - manage_labels: "Create label: {labelName}" / "Add label '{labelName}' to {identifier}" / "Remove label '{labelName}' from {identifier}"

11. Add buildResultSummary cases for each with appropriate success messages.
  </action>
  <verify>
Run `npx tsc --noEmit -p apps/server/tsconfig.json` -- should compile with no errors. Verify manage_project, manage_cycle, manage_labels exist in tool definitions, metadata, and handlers.
  </verify>
  <done>
Three workflow write tools (manage_project, manage_cycle, manage_labels) registered with full Linear API integration. Linear adapter has project, cycle, and label mutation methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register bulk_update_issues tool with table preview and partial failure handling</name>
  <files>
    apps/server/src/tools/index.ts
    apps/server/src/services/approvalManager.ts
  </files>
  <action>
**In tools/index.ts:**

1. Add **bulk_update_issues** tool definition:
   - Parameters:
     - issueIds (array of strings, required -- accepts identifiers like ["ENG-123", "ENG-456"])
     - updates (object with optional fields: priority (number|null), assigneeName (string|null), status (string|null), labelNames (array of strings|null), projectName (string|null))
   - strict: true, additionalProperties: false on all levels

2. Add toolMetadata for bulk_update_issues:
   - requiresApproval: true, category: "action", actionCategory: "linear"
   - descriptionForUser: "Update multiple Linear issues at once"
   - generatePreview: For each issueId, create an ActionPreviewField with field: "Issue" and newValue showing the identifier. Then for each update field, add a field showing what changes. The preview should produce a flat list that the approval card can render as a table (per user decision: "each issue on its own row showing title, current state, and new state").
   - To make the table preview work, use a structured approach: each ActionPreviewField represents one row. Use field format "issue:{identifier}" with oldValue as current value and newValue as the new value. The approval card enhancement in Plan 03 will parse this structure.
   - Alternative simpler approach: generate preview fields like:
     ```
     { field: "Issues", newValue: "ENG-123, ENG-456, ENG-789 (3 issues)" }
     { field: "Set Priority", newValue: "High" }
     { field: "Set Assignee", newValue: "Alice" }
     ```
     Plus a warning field if count > 10:
     ```
     { field: "Warning", newValue: "Bulk operation affects 15 issues. Please review carefully." }
     ```
   Use this simpler approach for the preview generator. The detailed per-issue table will be built in the approval card enhancement (Plan 03) which reads the raw toolArguments.

3. Add bulk_update_issues handler:
   - Validate issueIds.length > 0
   - If issueIds.length > 10, add a warning to the log but proceed (per user decision: "soft cap with warning but still allow")
   - Resolve identifiers to UUIDs by searching db for each
   - Resolve names to IDs (assigneeName, status, labelNames, projectName) once -- shared across all issues
   - Iterate over each issue and call linear.updateIssue() individually
   - Track successes and failures separately
   - If all succeed: return { success: true, updatedCount: N, results: [...] }
   - If some fail: return { partialSuccess: true, updatedCount: N, failedCount: M, results: [...], failures: [...] } (per user decision: "partial failure handling: mark action as partially succeeded, show which items succeeded and which failed with reasons")
   - If all fail: return { success: false, error: "All updates failed", failures: [...] }

**In approvalManager.ts:**

4. Add buildDescription for bulk_update_issues:
   - "Update {N} issues: {field summary}" (e.g., "Update 5 issues: set priority to High, assign to Alice")
   - If N > 10, append " (large batch)"

5. Add buildResultSummary for bulk_update_issues:
   - Full success: "Updated {N} issues successfully"
   - Partial: "Updated {success}/{total} issues ({failed} failed)"
   - Handle the partialSuccess flag: when parsed.partialSuccess is true, the approval manager should mark the result differently. Since the state machine only has "succeeded" and "failed", use "succeeded" with a result string that clearly indicates partial success. The user will see "Updated 3/5 issues (2 failed)" in the result summary.

6. Add special handling in ApprovalManager.execute() for bulk results: if parsed.partialSuccess is true, still call markSucceeded (the action was executed) but include the failure details in the result string. This accurately reflects the outcome -- the action ran but had mixed results.
  </action>
  <verify>
Run `npx tsc --noEmit -p apps/server/tsconfig.json` -- should compile cleanly. Verify bulk_update_issues exists in tool definitions, metadata, and handlers. Check that the handler implements partial failure tracking.
  </verify>
  <done>
bulk_update_issues tool registered with preview showing issue count and change summary, soft-cap warning above 10 issues, sequential execution with partial failure tracking, and human-readable result summaries distinguishing full success from partial success.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit -p apps/server/tsconfig.json`
2. manage_project, manage_cycle, manage_labels, bulk_update_issues exist in tool definitions
3. All four have requiresApproval: true and actionCategory: "linear" in metadata
4. bulk_update_issues handler returns partialSuccess field when some updates fail
5. bulk_update_issues preview includes warning when >10 issues
6. linearGraphql.ts has createProject, updateProject, addIssueToCycle, removeIssueFromCycle, createLabel methods
7. approvalManager.ts handles all four new tools in buildDescription and buildResultSummary
</verification>

<success_criteria>
- All Linear workflow operations (projects, cycles, labels, bulk) are available as write tools
- Bulk operations show issue count, change summary, and soft-cap warning in preview
- Partial failure produces a clear result distinguishing successes from failures
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-linear-internal-write-actions/02-02-SUMMARY.md`
</output>
