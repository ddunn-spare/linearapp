---
phase: 02-linear-internal-write-actions
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - apps/server/src/tools/index.ts
  - apps/server/src/services/approvalManager.ts
autonomous: true

must_haves:
  truths:
    - "Agent can propose creating an OKR with objective, quarter, owner, and key results"
    - "Agent can propose updating an OKR's fields or its key results"
    - "Agent can propose deleting an OKR"
    - "Agent can propose updating a key result's current value (progress)"
    - "Agent can propose linking or unlinking an issue to a key result"
    - "Agent proactively suggests issue-to-KR links when it sees a match"
  artifacts:
    - path: "apps/server/src/tools/index.ts"
      provides: "OKR write tool definitions, metadata, and handlers"
      contains: "create_okr"
    - path: "apps/server/src/services/approvalManager.ts"
      provides: "Descriptions and summaries for OKR tools"
      contains: "create_okr"
  key_links:
    - from: "apps/server/src/tools/index.ts"
      to: "apps/server/src/db.ts"
      via: "OKR tool handlers call existing StateDb OKR methods"
      pattern: "db\\.(upsertOkr|deleteOkr|updateKeyResultProgress|getOkrs|getOkrById)"
    - from: "apps/server/src/services/approvalManager.ts"
      to: "apps/server/src/tools/index.ts"
      via: "buildDescription and buildResultSummary switch on OKR tool names"
      pattern: "case \"(create_okr|update_okr|delete_okr|update_key_result|link_issue_to_kr)\""
---

<objective>
Register OKR write tools (create_okr, update_okr, delete_okr, update_key_result, link_issue_to_kr) using existing database operations. OKR tools are internal (no external API calls) and use the existing OKR CRUD in StateDb.

Purpose: Completes the internal write action surface -- users can manage OKRs and connect issues to key results directly through chat, with auto-progress calculation.
Output: Five OKR write tools flowing through the approval infrastructure, with color-coded "okr" category for visual differentiation.
</objective>

<execution_context>
@/Users/devondunn/.claude/get-shit-done/workflows/execute-plan.md
@/Users/devondunn/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-linear-internal-write-actions/02-01-SUMMARY.md

@apps/server/src/tools/index.ts
@apps/server/src/services/approvalManager.ts
@apps/server/src/routes/okrs.ts
@apps/server/src/db.ts
@packages/shared/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register OKR write tools with definitions, metadata, and handlers</name>
  <files>
    apps/server/src/tools/index.ts
    apps/server/src/services/approvalManager.ts
  </files>
  <action>
**In tools/index.ts -- add five OKR tool definitions with strict mode:**

1. **create_okr** tool:
   - Parameters: objective (string, required), quarter (string, required -- e.g. "Q1 2026"), owner (string, required), keyResults (array of objects with { description: string, targetValue: number, unit: string }, required, minItems conceptually enforced in handler)
   - Metadata: requiresApproval: true, category: "action", actionCategory: "okr", descriptionForUser: "Create a new OKR with key results"
   - generatePreview: Show Objective, Quarter, Owner, and each key result as "{description} (target: {targetValue} {unit})"
   - Handler: Generate okrId via crypto.randomUUID(). Build OkrDoc and KeyResult[] following the exact pattern from routes/okrs.ts POST handler (compute progress from currentValue/targetValue, compute avgProgress). Call db.upsertOkr(). Return { success: true, okrId, objective }.

2. **update_okr** tool:
   - Parameters: okrId (string, required), objective (string|null), quarter (string|null), owner (string|null), status (string|null), keyResults (array of { id: string|null, description: string, targetValue: number, currentValue: number, unit: string }|null)
   - Metadata: requiresApproval: true, category: "action", actionCategory: "okr", descriptionForUser: "Update an existing OKR or its key results"
   - generatePreview: Show only the fields being changed. For keyResults, show "Key Results: {count} key results updated"
   - Handler: Fetch existing OKR via db.getOkrById(). If not found, return error. Merge fields following the routes/okrs.ts PUT pattern. Recompute progress. Call db.upsertOkr(). Return { success: true, okrId, objective }.

3. **delete_okr** tool:
   - Parameters: okrId (string, required)
   - Metadata: requiresApproval: true, category: "action", actionCategory: "okr", descriptionForUser: "Delete an OKR and all its key results", destructive: true
   - generatePreview: Fetch OKR from db to show objective text in preview (not just the ID). Show { field: "Objective", newValue: objective }, { field: "Quarter", newValue: quarter }.
   - Handler: Verify OKR exists. Call db.deleteOkr(). Return { success: true, okrId, objective }.

4. **update_key_result** tool:
   - Parameters: keyResultId (string, required), currentValue (number, required)
   - Metadata: requiresApproval: true, category: "action", actionCategory: "okr", descriptionForUser: "Update a key result's progress"
   - generatePreview: Show key result ID and new value. If possible, look up the KR description from db to enrich the preview.
   - Handler: Call db.updateKeyResultProgress(keyResultId, currentValue). Return { success: true, keyResultId, currentValue }. Note: The existing db method handles progress recalculation.

5. **link_issue_to_kr** tool:
   - Parameters: issueId (string, required -- accepts identifier), keyResultId (string, required), action (string, enum ["link", "unlink"], required)
   - Metadata: requiresApproval: true, category: "action", actionCategory: "okr", descriptionForUser: "Link or unlink an issue to a key result for OKR tracking"
   - generatePreview: Show issue identifier, key result description, and action (link/unlink)
   - Handler: For "link" -- update the issue's enrichment to set okrId to the parent OKR of the key result. Look up the KR's okrId by querying db. Use db to update the enrichment's okrId field. For "unlink" -- clear the okrId from the enrichment. After linking/unlinking, recalculate the OKR's issueCount.
   - The existing enrichment storage has okrId field. To link, we need to update or create an enrichment record. Check if db has an updateEnrichmentOkr method. If not, use the existing upsert pattern: get current enrichment, modify okrId, save back.
   - Return: { success: true, issueIdentifier, keyResultId, action }

**Per user decision -- "Agent proactively suggests issue-to-KR links when it sees a match":**
This behavior is driven by the system prompt, not by tool implementation. The system prompt (auto-generated from tool registry in chatService.ts buildSystemPrompt()) already lists write tools. To enable proactive suggestions, add a note to the link_issue_to_kr tool's OpenAI description: "Link an issue to a key result for OKR tracking. Proactively suggest this when you notice an issue's work aligns with a key result based on title, description, or labels."

**Per user decision -- "Auto-calculate key result progress from linked issue data and propose the update for approval":**
Add a note to the update_key_result tool description: "Update a key result's current progress value. When issues linked to a KR are completed, proactively suggest updating the KR progress based on the completion data."

**In approvalManager.ts:**

6. Add buildDescription cases for all five OKR tools:
   - create_okr: "Create OKR: {objective} ({quarter})"
   - update_okr: "Update OKR: {objective or okrId} -- {list of changed fields}"
   - delete_okr: "Delete OKR: {objective}" (use objective from args or look up from db)
   - update_key_result: "Update key result progress: {currentValue}"
   - link_issue_to_kr: "Link {identifier} to key result" / "Unlink {identifier} from key result"

7. Add buildResultSummary cases:
   - create_okr: "Created OKR: {objective}"
   - update_okr: "Updated OKR: {objective}"
   - delete_okr: "Deleted OKR: {objective}"
   - update_key_result: "Key result progress updated to {currentValue}"
   - link_issue_to_kr: "Issue {linked/unlinked} {to/from} key result"
  </action>
  <verify>
Run `npx tsc --noEmit -p apps/server/tsconfig.json` -- should compile cleanly. Verify create_okr, update_okr, delete_okr, update_key_result, link_issue_to_kr exist in tool definitions, metadata, and handlers. Verify all have actionCategory: "okr". Verify delete_okr has destructive: true.
  </verify>
  <done>
Five OKR write tools registered: create_okr, update_okr, delete_okr, update_key_result, link_issue_to_kr. All tagged with actionCategory "okr" for color-coded approval cards. Proactive suggestion behavior wired via tool descriptions that guide the LLM. Delete OKR marked as destructive.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add proposal category to approval flow and enhance system prompt for OKR proactivity</name>
  <files>
    apps/server/src/services/approvalManager.ts
    apps/server/src/services/chatService.ts
  </files>
  <action>
**In approvalManager.ts:**

1. Update the `createProposal` method to set the `category` field on the ActionProposal based on the tool's actionCategory from metadata. Import `getToolMetadata` (if not already imported) and `getToolActionCategory` (added in Plan 01). When creating the proposal, look up the tool's actionCategory and set it on the proposal:
   ```typescript
   const meta = getToolMetadata(params.toolName);
   const category = meta?.actionCategory || "internal";
   ```
   Pass `category` into the stateMachine.createProposal() call. This requires updating the stateMachine to accept and store the category field.

2. Update ActionStateMachine (in actionStateMachine.ts) to accept `category` in createProposal params and pass it through to the DB. The action_proposals table already stores JSON so the category can be added to the proposal object. Check if createProposal already accepts arbitrary fields or if we need to add `category` to the params type.

   If the DB schema uses column-based storage (not JSON), add a `category` column:
   ```sql
   ALTER TABLE action_proposals ADD COLUMN category TEXT DEFAULT 'internal';
   ```
   Handle this in the schema migration (db.ts ensureSchema or equivalent).

**In chatService.ts:**

3. Enhance the system prompt section for write tools to group them by category. Instead of a flat list, organize as:
   ```
   Linear Actions (require approval):
   - Create a new issue in Linear
   - Update an existing Linear issue
   ...

   OKR Actions (require approval):
   - Create a new OKR with key results
   - Link or unlink an issue to a key result
   ...
   ```
   Update buildSystemPrompt() to group getWriteToolSummaries() results by actionCategory. Add a new export `getWriteToolSummariesGrouped()` in tools/index.ts that returns `Map<string, { name: string; description: string }[]>` grouped by actionCategory, or just group in buildSystemPrompt directly.

4. Add proactive instruction to the system prompt for OKR linking:
   After the write tools section, add:
   "When you retrieve issue details or search results, look for opportunities to suggest linking issues to key results. If an issue's title, description, or labels align with a key result's description, proactively suggest using link_issue_to_kr. Similarly, when issues linked to a key result are completed, suggest using update_key_result to update the progress."
  </action>
  <verify>
Run `npx tsc --noEmit -p apps/server/tsconfig.json` -- should compile cleanly. Verify that ActionProposal objects created by approvalManager now include a category field. Verify the system prompt groups tools by category (start the server and check logs, or read the buildSystemPrompt output).
  </verify>
  <done>
ActionProposal carries a category field ("linear" | "okr" | "internal") persisted to database. System prompt groups write tools by category and includes proactive OKR linking instructions. The approval card can now differentiate Linear vs OKR actions visually.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit -p apps/server/tsconfig.json`
2. Five OKR tools exist: create_okr, update_okr, delete_okr, update_key_result, link_issue_to_kr
3. All OKR tools have actionCategory: "okr" in metadata
4. delete_okr has destructive: true
5. ActionProposal includes category field in DB storage
6. System prompt groups tools by category (Linear Actions vs OKR Actions)
7. System prompt includes proactive OKR linking instruction
</verification>

<success_criteria>
- All five OKR write tools are functional: definitions, metadata, handlers, approval integration
- Proposals carry category for downstream UI differentiation
- System prompt guides the agent to proactively suggest OKR links and progress updates
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-linear-internal-write-actions/02-03-SUMMARY.md`
</output>
