---
phase: 01-approval-infrastructure-flow
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - apps/server/src/tools/index.ts
  - apps/server/src/services/approvalManager.ts
  - apps/server/src/services/chatService.ts
  - apps/server/src/routes/chat.ts
  - apps/server/src/app.ts
autonomous: true

must_haves:
  truths:
    - "Tools are classified as read-only or write (requiresApproval) with metadata for preview generation"
    - "When the agent calls a write tool, the chat service creates an action proposal instead of executing the tool"
    - "Approve, decline, and retry HTTP endpoints exist and correctly transition action state"
    - "The system prompt accurately lists available write actions so the agent knows its capabilities (DISC-03)"
  artifacts:
    - path: "apps/server/src/tools/index.ts"
      provides: "Tool registry with read/write classification, strict mode schemas, and preview generators"
      contains: "requiresApproval"
    - path: "apps/server/src/services/approvalManager.ts"
      provides: "ApprovalManager orchestrating proposal creation, execution, and decline handling"
      exports: ["ApprovalManager"]
    - path: "apps/server/src/routes/chat.ts"
      provides: "POST /api/chat/actions/:id/approve, POST /api/chat/actions/:id/decline, POST /api/chat/actions/:id/retry endpoints"
      contains: "actions/:id/approve"
    - path: "apps/server/src/services/chatService.ts"
      provides: "Integration with ApprovalManager for write tool interception"
      contains: "approvalManager"
  key_links:
    - from: "apps/server/src/services/chatService.ts"
      to: "apps/server/src/services/approvalManager.ts"
      via: "write tool interception in function-calling loop"
      pattern: "approvalManager\\.createProposal"
    - from: "apps/server/src/routes/chat.ts"
      to: "apps/server/src/services/approvalManager.ts"
      via: "approve/decline/retry endpoint handlers"
      pattern: "approvalManager\\.(approve|decline|retry)"
    - from: "apps/server/src/services/approvalManager.ts"
      to: "apps/server/src/services/actionStateMachine.ts"
      via: "state transitions during execution"
      pattern: "stateMachine\\.(approve|markExecuting|markSucceeded|markFailed)"
---

<objective>
Build the tool registry classification system, ApprovalManager service, action endpoints, and system prompt auto-generation.

Purpose: This plan connects the state machine infrastructure (from 01-01) to the tool execution system. It creates the critical interception point where write tools produce proposals instead of executing directly, and provides the API endpoints for the frontend to approve/decline/retry actions. The system prompt auto-generation ensures the agent knows about its write capabilities (DISC-03).

Output: Extended tool registry with read/write classification, ApprovalManager service, approve/decline/retry REST endpoints, and dynamic system prompt generation.
</objective>

<execution_context>
@/Users/devondunn/.claude/get-shit-done/workflows/execute-plan.md
@/Users/devondunn/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-approval-infrastructure-flow/01-CONTEXT.md
@.planning/phases/01-approval-infrastructure-flow/01-01-SUMMARY.md
@apps/server/src/tools/index.ts
@apps/server/src/services/chatService.ts
@apps/server/src/routes/chat.ts
@apps/server/src/app.ts
@packages/shared/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend tool registry with read/write classification and strict mode</name>
  <files>
    apps/server/src/tools/index.ts
  </files>
  <action>
Refactor the tool registry in `apps/server/src/tools/index.ts` to support write tool metadata.

**1. Define a ToolDefinition type** (internal to this module):

```typescript
type ToolMetadata = {
  requiresApproval: boolean;
  category: "query" | "action";
  descriptionForUser: string;  // Plain-language for system prompt auto-gen (DISC-03)
  generatePreview?: (args: Record<string, unknown>) => ActionPreviewField[];
};
```

Import `ActionPreviewField` from `@linearapp/shared`.

**2. Create a metadata registry** — a `Map<string, ToolMetadata>` that maps tool names to their metadata. For all existing tools, set `requiresApproval: false` and `category: "query"`. Example:

```typescript
const toolMetadata: Map<string, ToolMetadata> = new Map([
  ["search_issues", { requiresApproval: false, category: "query", descriptionForUser: "Search issues by keyword" }],
  ["get_issue_detail", { requiresApproval: false, category: "query", descriptionForUser: "Get details of a specific issue" }],
  // ... all 12 existing tools
]);
```

**3. Add a demo write tool** for end-to-end testing (this will be replaced by real Linear tools in Phase 2, but we need something testable now). Add to the tool definitions array:

```typescript
{
  type: "function",
  function: {
    name: "demo_create_issue",
    description: "Create a new issue in Linear (demo tool for testing approval flow)",
    strict: true,  // INFRA-02: strict mode prevents hallucinated parameters
    parameters: {
      type: "object",
      properties: {
        title: { type: "string", description: "Issue title" },
        description: { type: "string", description: "Issue description" },
        priority: { type: "number", description: "Priority (0=none, 1=urgent, 2=high, 3=medium, 4=low)", enum: [0, 1, 2, 3, 4] },
        assigneeName: { type: "string", description: "Name of the person to assign" },
      },
      required: ["title"],
      additionalProperties: false,
    },
  },
}
```

Add its metadata:
```typescript
["demo_create_issue", {
  requiresApproval: true,
  category: "action",
  descriptionForUser: "Create a new issue in Linear",
  generatePreview: (args) => {
    const fields: ActionPreviewField[] = [];
    fields.push({ field: "Title", newValue: String(args.title || "") });
    if (args.description) fields.push({ field: "Description", newValue: String(args.description) });
    if (args.priority !== undefined) {
      const labels = ["None", "Urgent", "High", "Medium", "Low"];
      fields.push({ field: "Priority", newValue: labels[Number(args.priority)] || "None" });
    }
    if (args.assigneeName) fields.push({ field: "Assignee", newValue: String(args.assigneeName) });
    return fields;
  },
}],
```

Add a demo handler that simulates success (for now — real handlers come in Phase 2):
```typescript
demo_create_issue: async (args) => {
  // Demo handler — simulates creating an issue
  const fakeId = `DEMO-${Math.floor(Math.random() * 1000)}`;
  return JSON.stringify({
    success: true,
    issueId: fakeId,
    identifier: fakeId,
    title: args.title,
    url: `https://linear.app/team/issue/${fakeId}`,
  });
},
```

**4. Add `strict: true` to ALL tool definitions** (INFRA-02) and add `additionalProperties: false` to all parameter objects. This prevents OpenAI from hallucinating extra parameters.

**5. Export new functions:**
- `getToolMetadata(toolName: string): ToolMetadata | undefined` — returns metadata for a tool
- `isWriteTool(toolName: string): boolean` — returns true if tool.requiresApproval
- `getWriteToolSummaries(): { name: string; description: string }[]` — returns list of write tools with descriptions (for system prompt)
- `generatePreviewForTool(toolName: string, args: Record<string, unknown>): ActionPreviewField[]` — calls the tool's generatePreview or returns a generic preview
  </action>
  <verify>
Run `cd apps/server && npx tsc --noEmit` — no type errors. Verify `getToolDefinitions()` returns all tools including demo_create_issue. Verify `isWriteTool("demo_create_issue")` returns true and `isWriteTool("search_issues")` returns false.
  </verify>
  <done>
Tool registry classifies all tools as read or write. All tool definitions use strict mode with additionalProperties:false (INFRA-02). Demo write tool exists for testing. Preview generation functions are exported. Tool metadata registry maps tool names to classification and user-facing descriptions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ApprovalManager service and integrate with chat service</name>
  <files>
    apps/server/src/services/approvalManager.ts
    apps/server/src/services/chatService.ts
    apps/server/src/app.ts
  </files>
  <action>
**Create `apps/server/src/services/approvalManager.ts`:**

The ApprovalManager orchestrates the full proposal-to-execution lifecycle. It sits between the chat service (which detects write tools) and the action state machine (which enforces state transitions).

**Constructor:** Takes `ActionStateMachine`, `ToolHandler` record (from tools/index.ts), and `StateDb`.

**Methods:**

1. `createProposal(params: { conversationId, messageId, toolName, toolArguments }): ActionProposal`
   - Import and use `generatePreviewForTool()` from tools/index.ts to create the preview fields
   - Generate a plain-language description by combining tool name and key arguments:
     ```typescript
     // Example: "Create issue: Fix login bug (Priority: High, Assignee: Devon)"
     const description = this.buildDescription(toolName, toolArguments, preview);
     ```
   - Delegate to `stateMachine.createProposal({ conversationId, messageId, toolName, toolArguments, description, preview })`
   - Return the created proposal

2. `async approve(proposalId: string): Promise<ActionProposal>`
   - Call `stateMachine.approve(proposalId)` to transition proposed -> approved
   - Return the approved proposal (execution happens in a separate `execute()` call)

3. `async execute(proposalId: string): Promise<ActionProposal>`
   - Call `stateMachine.markExecuting(proposalId)` — this is the idempotency gate (INFRA-05). If already executing/succeeded, returns existing proposal without re-executing.
   - Look up the tool handler: `this.toolHandlers[proposal.toolName]`
   - If no handler, mark failed with "Tool handler not found"
   - Try executing the handler: `const result = await handler(proposal.toolArguments)`
   - Parse the result JSON. If result contains `success: true` or any data, mark succeeded with a summary and optional URL
   - If result contains `error`, mark failed with the error message
   - On catch, mark failed with the exception message
   - Return the final proposal state

4. `async decline(proposalId: string): Promise<ActionProposal>`
   - Call `stateMachine.decline(proposalId)`
   - Return the declined proposal

5. `async retry(proposalId: string): Promise<ActionProposal>`
   - Load proposal from state machine
   - Verify state is "failed" (only failed actions can be retried per user decision)
   - Call `execute(proposalId)` — markExecuting handles the failed -> executing transition
   - Return final result

6. `getProposal(proposalId: string): ActionProposal | null` — delegate to stateMachine

7. `getProposalsByConversation(conversationId: string): ActionProposal[]` — delegate to db

**Private helper:** `buildDescription(toolName: string, args: Record<string, unknown>, preview: ActionPreviewField[]): string`
   - Human-readable description. E.g., for "demo_create_issue" with title "Fix bug": "Create issue: Fix bug"
   - Use a switch on toolName for known tools, fallback to generic "Execute {toolName}"

**Update `apps/server/src/services/chatService.ts`:**

Modify the `handleMessageStream()` method (created in 01-01) to intercept write tool calls:

1. Add `approvalManager: ApprovalManager` to the constructor (new dependency)
2. In the tool execution section of the function-calling loop, BEFORE executing a tool handler:
   ```typescript
   if (isWriteTool(toolName)) {
     // Don't execute — create a proposal instead
     const proposal = this.approvalManager.createProposal({
       conversationId,
       messageId: pendingAssistantMsgId, // generate the assistant message ID early
       toolName,
       toolArguments: parsedArgs,
     });
     yield { type: "action_proposed", proposal };

     // Feed back a synthetic tool result to OpenAI telling it the action was proposed
     const proposalResult = JSON.stringify({
       status: "proposed_for_approval",
       proposalId: proposal.id,
       description: proposal.description,
       message: "This action has been proposed to the user for approval. Wait for their decision before proceeding.",
     });
     // Push tool result message for OpenAI
     messages.push({ role: "tool", tool_call_id: tc.id, content: proposalResult });
     toolCalls.push({ id: tc.id, name: toolName, arguments: toolArgs, result: proposalResult });
     continue; // Skip normal tool execution
   }
   ```
3. This way, when OpenAI calls a write tool, the user sees a proposal card, and OpenAI receives a "proposed for approval" response so it can acknowledge to the user naturally.

**Update `apps/server/src/app.ts`:**

1. Import `ActionStateMachine` and `ApprovalManager`
2. In `createApp()`, after creating `chatService`:
   ```typescript
   const actionStateMachine = new ActionStateMachine(db);
   const toolHandlers = createToolHandlers(db, trackedLinearIds);
   const approvalManager = new ApprovalManager(actionStateMachine, toolHandlers, db);
   ```
3. Pass `approvalManager` to `ChatService` constructor (update constructor to accept it)
4. Pass `approvalManager` to `registerChatRoutes()` (needed for next task's endpoints)
  </action>
  <verify>
1. Run `cd apps/server && npx tsc --noEmit` — no type errors
2. Start dev server. In chat, say "Create an issue called Test Bug with high priority"
3. Verify the agent:
   - Calls demo_create_issue tool
   - An action_proposed SSE event is emitted (check browser DevTools Network tab, SSE messages)
   - OpenAI receives "proposed_for_approval" and responds acknowledging the proposal
   - The tool is NOT executed (no DEMO-xxx ID generated yet)
  </verify>
  <done>
ApprovalManager service orchestrates the full lifecycle. Write tools produce proposals instead of executing. The chat service integrates with ApprovalManager to intercept write tool calls. OpenAI receives "proposed for approval" feedback and can acknowledge naturally. The app.ts wires everything together.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add approval action endpoints and system prompt auto-generation</name>
  <files>
    apps/server/src/routes/chat.ts
    apps/server/src/services/chatService.ts
  </files>
  <action>
**Add action endpoints to `apps/server/src/routes/chat.ts`:**

Update `registerChatRoutes` to accept `approvalManager: ApprovalManager` as an additional parameter.

1. **POST `/api/chat/actions/:id/approve`** — Approve and execute a proposed action
   ```typescript
   app.post("/api/chat/actions/:id/approve", async (request, reply) => {
     const { id } = request.params as { id: string };
     try {
       const approved = await approvalManager.approve(id);
       const executed = await approvalManager.execute(id);
       return { ok: true, proposal: executed };
     } catch (error) {
       const msg = error instanceof Error ? error.message : "Approve failed";
       return reply.status(400).send({ ok: false, error: msg });
     }
   });
   ```

2. **POST `/api/chat/actions/:id/decline`** — Decline a proposed action
   ```typescript
   app.post("/api/chat/actions/:id/decline", async (request, reply) => {
     const { id } = request.params as { id: string };
     try {
       const declined = await approvalManager.decline(id);
       return { ok: true, proposal: declined };
     } catch (error) {
       const msg = error instanceof Error ? error.message : "Decline failed";
       return reply.status(400).send({ ok: false, error: msg });
     }
   });
   ```

3. **POST `/api/chat/actions/:id/retry`** — Retry a failed action
   ```typescript
   app.post("/api/chat/actions/:id/retry", async (request, reply) => {
     const { id } = request.params as { id: string };
     try {
       const retried = await approvalManager.retry(id);
       return { ok: true, proposal: retried };
     } catch (error) {
       const msg = error instanceof Error ? error.message : "Retry failed";
       return reply.status(400).send({ ok: false, error: msg });
     }
   });
   ```

4. **GET `/api/chat/conversations/:id/proposals`** — Get all proposals for a conversation (for re-rendering on refresh, INFRA-04)
   ```typescript
   app.get("/api/chat/conversations/:id/proposals", async (request) => {
     const { id } = request.params as { id: string };
     const proposals = approvalManager.getProposalsByConversation(id);
     return { proposals };
   });
   ```

**System prompt auto-generation (DISC-03):**

In `apps/server/src/services/chatService.ts`:

1. Replace the hardcoded `SYSTEM_PROMPT` constant with a function `buildSystemPrompt()`:
   ```typescript
   function buildSystemPrompt(): string {
     const writeTools = getWriteToolSummaries();
     const writeSection = writeTools.length > 0
       ? `\n\nYou can also take actions on behalf of the user (these require user approval before execution):\n${writeTools.map(t => `- ${t.description}`).join("\n")}\n\nWhen you want to take an action, use the appropriate tool. The user will see a preview of what will change and can approve or decline. If they decline, acknowledge naturally and move on — do not ask follow-up questions about the declined action. If they approve, the action will execute and you'll see the result.`
       : "";

     return `You are Team Hub AI, an intelligent assistant for the EAM engineering team. You help manage work using a "Shaped Kanban with OKR Guardrails" methodology.

Your capabilities:
- Search and analyze issues from Linear
- Check team workload and recommend assignments
- Track cycle progress and identify risks
- Evaluate OKR alignment for work items
- Review GitHub PRs and review status
- Calculate RICE scores for prioritization
- Run ad-hoc queries against the team database${writeSection}

Key principles you follow:
- Flow over utilization — minimize context switching
- WIP limits matter — never overload team members (5 max in-progress)
- Every piece of work should align to an OKR when possible
- Use RICE scoring to prioritize objectively
- Make work visible — surface blockers and risks proactively

When answering questions, use your available tools to get real data. Don't guess — call the appropriate tool and base your answers on actual data.`;
   }
   ```

2. Use `buildSystemPrompt()` instead of the `SYSTEM_PROMPT` constant in `handleMessageStream()` (and the deprecated `handleMessage()` if kept).

3. Import `getWriteToolSummaries` from `../tools/index`.

**User decision compliance:** The system prompt instructs the agent to "acknowledge naturally and move on" when declined (per locked decision: "On decline: agent acknowledges and moves on naturally, no follow-up questions"). And it tells the agent about available write actions (DISC-03).

**Update app.ts** `registerChatRoutes` call to pass `approvalManager`:
```typescript
registerChatRoutes(app, db, chatService, approvalManager);
```
  </action>
  <verify>
1. Run `cd apps/server && npx tsc --noEmit` — no type errors
2. Test approve endpoint: Start dev server, trigger a write tool proposal via chat, note the proposal ID from the SSE event, then:
   ```bash
   curl -X POST http://localhost:7917/api/chat/actions/{proposalId}/approve
   ```
   Verify response includes `ok: true` and proposal state is "succeeded"
3. Test decline endpoint similarly — verify state becomes "declined"
4. Test idempotency: Call approve twice on the same proposal — second call should return the already-executed result, not re-execute
5. Verify system prompt includes write tool descriptions by checking the first SSE messages or by logging
  </verify>
  <done>
Approve, decline, and retry HTTP endpoints exist and return correct action proposal states. Proposals endpoint supports refresh persistence (INFRA-04). System prompt is auto-generated from the tool registry and includes write action descriptions (DISC-03). Decline instruction tells the agent to move on naturally (APPR-07). Idempotency prevents double-execution through the approve endpoint.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes from repo root
2. Tools are classified: `isWriteTool("demo_create_issue")` returns true, `isWriteTool("search_issues")` returns false
3. All tool definitions have `strict: true` and `additionalProperties: false` (INFRA-02)
4. Chat service intercepts write tool calls and creates proposals instead of executing
5. POST `/api/chat/actions/:id/approve` executes the action and returns succeeded state
6. POST `/api/chat/actions/:id/decline` marks action declined
7. POST `/api/chat/actions/:id/retry` re-executes a failed action
8. Calling approve twice on same proposal does not execute twice (idempotency)
9. System prompt includes write tool descriptions
10. GET `/api/chat/conversations/:id/proposals` returns proposals for refresh persistence
</verification>

<success_criteria>
- Write tools are identified via requiresApproval metadata and intercepted in the chat loop
- ApprovalManager creates proposals, executes on approve, declines on decline, retries on failure
- REST endpoints exist for approve/decline/retry/list-proposals
- System prompt is auto-generated from tool registry with write action descriptions (DISC-03)
- Idempotency prevents double-execution via state machine guards (INFRA-05)
- All existing read-only tool functionality is unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/01-approval-infrastructure-flow/01-02-SUMMARY.md`
</output>
