---
phase: 01-approval-infrastructure-flow
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - apps/web/src/components/ApprovalCard.tsx
  - apps/web/src/pages/ChatPage.tsx
  - apps/web/src/api.ts
  - packages/shared/src/index.ts
autonomous: false

must_haves:
  truths:
    - "Approval card appears inline in chat showing diff-style field-by-field preview of what will change"
    - "User can click Approve (primary button) or Decline (secondary) to act on a proposal"
    - "Approved action shows executing spinner, then collapses to compact success result with link"
    - "Failed action shows red error state with plain-language explanation and Retry button"
    - "Declined action is acknowledged by the agent naturally"
    - "Multiple actions show individual cards with Approve All shortcut when 2+ are pending"
    - "Action state persists across page refresh (proposals reload from server)"
    - "Smooth transitions between lifecycle states with subtle animations"
  artifacts:
    - path: "apps/web/src/components/ApprovalCard.tsx"
      provides: "Approval card component with all lifecycle states (proposed, executing, succeeded, failed, declined)"
      exports: ["ApprovalCard"]
    - path: "apps/web/src/pages/ChatPage.tsx"
      provides: "Chat page rendering approval cards inline, handling approve/decline/retry, Approve All"
      contains: "ApprovalCard"
    - path: "apps/web/src/api.ts"
      provides: "API functions for approveAction, declineAction, retryAction, getConversationProposals"
      contains: "approveAction"
  key_links:
    - from: "apps/web/src/pages/ChatPage.tsx"
      to: "apps/web/src/components/ApprovalCard.tsx"
      via: "renders ApprovalCard for each action proposal in message"
      pattern: "<ApprovalCard"
    - from: "apps/web/src/components/ApprovalCard.tsx"
      to: "apps/web/src/api.ts"
      via: "calls approveAction/declineAction/retryAction on button click"
      pattern: "approveAction|declineAction|retryAction"
    - from: "apps/web/src/pages/ChatPage.tsx"
      to: "apps/web/src/api.ts"
      via: "loads proposals on conversation change for refresh persistence"
      pattern: "getConversationProposals"
---

<objective>
Build the approval card UI component, integrate it into the chat page, and wire up the end-to-end approval flow from proposal to execution.

Purpose: This plan delivers the user-facing approval experience — the visual cards, interactive buttons, lifecycle animations, and the complete flow from seeing a proposal to approving/declining it and seeing the result. This is where the infrastructure from Plans 01 and 02 becomes a real user feature.

Output: ApprovalCard component with all lifecycle states, ChatPage integration with inline cards, API client functions for user actions, and a working end-to-end approval flow.
</objective>

<execution_context>
@/Users/devondunn/.claude/get-shit-done/workflows/execute-plan.md
@/Users/devondunn/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-approval-infrastructure-flow/01-CONTEXT.md
@.planning/phases/01-approval-infrastructure-flow/01-01-SUMMARY.md
@.planning/phases/01-approval-infrastructure-flow/01-02-SUMMARY.md
@apps/web/src/pages/ChatPage.tsx
@apps/web/src/api.ts
@apps/web/src/components/ApprovalCard.tsx
@packages/shared/src/index.ts
@apps/web/src/theme.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ApprovalCard component with all lifecycle states</name>
  <files>
    apps/web/src/components/ApprovalCard.tsx
    apps/web/src/api.ts
  </files>
  <action>
**Add API functions to `apps/web/src/api.ts`:**

Add under a new section `// --- Actions/Approvals ---`:

```typescript
export const approveAction = (proposalId: string) =>
  request<{ ok: boolean; proposal: ActionProposal }>(`/chat/actions/${proposalId}/approve`, { method: "POST" });

export const declineAction = (proposalId: string) =>
  request<{ ok: boolean; proposal: ActionProposal }>(`/chat/actions/${proposalId}/decline`, { method: "POST" });

export const retryAction = (proposalId: string) =>
  request<{ ok: boolean; proposal: ActionProposal }>(`/chat/actions/${proposalId}/retry`, { method: "POST" });

export const getConversationProposals = (conversationId: string) =>
  request<{ proposals: ActionProposal[] }>(`/chat/conversations/${conversationId}/proposals`);
```

Import `ActionProposal` from `@linearapp/shared`.

**Create `apps/web/src/components/ApprovalCard.tsx`:**

A single component that renders differently based on `ActionState`. This is a first-class UI element (per user emphasis), not a bolted-on widget.

**Props:**
```typescript
type ApprovalCardProps = {
  proposal: ActionProposal;
  onApprove: (id: string) => void;
  onDecline: (id: string) => void;
  onRetry: (id: string) => void;
};
```

**Lifecycle states to render:**

1. **Proposed** (pending approval):
   - Visually distinct bordered container with subtle background color (e.g., `rgba(33, 150, 243, 0.06)` blue tint with `1px solid rgba(33, 150, 243, 0.2)` border)
   - Header: MUI `BuildIcon` + plain-language description text (from `proposal.description`)
   - Body: Diff-style preview — render each `ActionPreviewField` as a row:
     - Field name (label, left-aligned, muted color)
     - Arrow or separator
     - If `oldValue` exists: show old value with strikethrough/red tint, then new value with green tint
     - If no `oldValue`: just show new value
     - Use MUI `Table` or a simple `Box` grid for alignment
   - Footer: Two buttons
     - **Approve** — MUI `Button` variant="contained" color="primary" (filled, primary — per user decision: "Approve button is primary")
     - **Decline** — MUI `Button` variant="text" color="inherit" (secondary text style — per user decision: "Decline is secondary (outline/text)")
   - Per locked decision: visually distinct card, bordered container with background color

2. **Executing** (after approve, waiting for result):
   - Same container but with a subtle pulsing border animation
   - Buttons REPLACED with a spinner (`CircularProgress` size 16) and "Executing..." text (per user decision: "buttons replaced with spinner and 'Executing...' text")
   - Preview section still visible but slightly faded
   - Use MUI `Fade`/`Collapse` for the transition from proposed to executing

3. **Succeeded** (execution complete):
   - Card COLLAPSES to compact single-line confirmation (per user decision: "card collapses to compact confirmation, single line")
   - Show: MUI `CheckCircleIcon` (green) + result text (e.g., "Issue created: DEMO-123")
   - If `resultUrl` exists, make the result text a clickable link (`<a href={resultUrl} target="_blank">`)
   - Background: subtle green tint `rgba(76, 175, 80, 0.06)`
   - No buttons — read-only (per user decision: "Resolved cards become read-only")
   - Use MUI `Collapse` to animate the height reduction from full card to compact

4. **Failed** (execution error):
   - Container with red border and red-tinted background `rgba(244, 67, 54, 0.06)`
   - Show: MUI `ErrorIcon` (red) + plain-language error text from `proposal.error` (per user decision: "card shows red/error state with plain-language explanation")
   - Show a **Retry** button (MUI `Button` variant="outlined" color="error") per user decision: "Failed cards show a 'Retry' button"
   - Read-only otherwise — no approve/decline buttons

5. **Declined** (user chose not to execute):
   - Compact single-line, similar to succeeded but with muted styling
   - Show: MUI `CancelIcon` (muted gray) + "Declined" text
   - No buttons — read-only
   - Very subtle styling, almost blends into the chat background

**Animation requirements** (per user decision: "Smooth transitions between states — subtle animations, fade/morph"):
- Use MUI `Collapse` for height transitions (proposed -> succeeded/declined)
- Use MUI `Fade` for opacity transitions between button states
- Keep animations under 300ms for snappy feel
- Use CSS transitions on border-color and background-color (150ms ease)

**Styling conventions:** Follow existing codebase pattern of inline `sx` props with MUI components. Use the app's dark theme colors. Reference existing component patterns from `StatusChip.tsx` and `ChatPage.tsx` for consistency.

**Important:** The card must handle rapid state changes gracefully. Use a `key` prop on the wrapper that includes the state to force re-render on state change. Disable the Approve button immediately on click (before API response) to prevent double-click at the UI level.
  </action>
  <verify>
1. Run `cd apps/web && npx tsc --noEmit` — no type errors
2. The component should render in isolation. Temporarily import it in ChatPage and render with mock data to verify each state visually.
  </verify>
  <done>
ApprovalCard component renders all 5 lifecycle states with correct visual treatment. Approve is primary/filled, Decline is secondary/text. Executing shows spinner. Succeeded collapses to compact line with link. Failed shows error with Retry button. Declined shows muted compact line. Smooth transitions between states. API client functions exist for approve/decline/retry/list-proposals.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate approval cards into ChatPage with full approval flow</name>
  <files>
    apps/web/src/pages/ChatPage.tsx
    packages/shared/src/index.ts
  </files>
  <action>
**Modify `apps/web/src/pages/ChatPage.tsx` to support the approval flow:**

1. **State management for proposals:**

   Add new state:
   ```typescript
   const [proposals, setProposals] = useState<Map<string, ActionProposal>>(new Map());
   ```

   This map stores all proposals by their ID, enabling quick lookups when the card needs the latest state.

2. **Load proposals on conversation change** (INFRA-04: persistence across refresh):

   In the existing `loadMessages` callback (or a new useEffect), also load proposals:
   ```typescript
   const loadProposals = useCallback(async (convId: string) => {
     try {
       const res = await getConversationProposals(convId);
       const map = new Map(res.proposals.map(p => [p.id, p]));
       setProposals(map);
     } catch { /* ignore */ }
   }, []);
   ```

   Call `loadProposals(activeConvId)` whenever `activeConvId` changes (alongside `loadMessages`).

3. **Handle SSE action events in the streaming handler:**

   In the `streamChat` event handler (inside `handleSend`), add cases:

   ```typescript
   case "action_proposed":
     setProposals(prev => new Map(prev).set(event.proposal.id, event.proposal));
     break;
   case "action_update":
     setProposals(prev => {
       const next = new Map(prev);
       const existing = next.get(event.proposalId);
       if (existing) {
         next.set(event.proposalId, {
           ...existing,
           state: event.state,
           result: event.result ?? existing.result,
           resultUrl: event.resultUrl ?? existing.resultUrl,
           error: event.error ?? existing.error,
           updatedAt: new Date().toISOString(),
         });
       }
       return next;
     });
     break;
   ```

4. **Render approval cards inline in assistant messages:**

   Modify the `AssistantMessage` component to accept and render proposals:

   ```typescript
   function AssistantMessage({ content, toolCalls, proposals, onApprove, onDecline, onRetry }: {
     content: string;
     toolCalls?: ChatMessage["toolCalls"];
     proposals?: ActionProposal[];
     onApprove: (id: string) => void;
     onDecline: (id: string) => void;
     onRetry: (id: string) => void;
   }) {
   ```

   After the content `Typography`, render proposals:
   ```tsx
   {proposals && proposals.length > 0 && (
     <Box sx={{ mt: 1.5, display: "flex", flexDirection: "column", gap: 1 }}>
       {proposals.length >= 2 && proposals.some(p => p.state === "proposed") && (
         <ApproveAllButton proposals={proposals} onApproveAll={handleApproveAll} />
       )}
       {proposals.map(p => (
         <ApprovalCard
           key={p.id}
           proposal={p}
           onApprove={onApprove}
           onDecline={onDecline}
           onRetry={onRetry}
         />
       ))}
     </Box>
   )}
   ```

   Per user decision: "Cards appear inline within the agent's chat message, not as separate elements below."

5. **Approve All shortcut** (per user decision: "'Approve All' shortcut appears when 2+ actions are pending"):

   Create a small inline component `ApproveAllButton`:
   ```typescript
   function ApproveAllButton({ proposals, onApproveAll }: { proposals: ActionProposal[]; onApproveAll: (ids: string[]) => void }) {
     const pendingIds = proposals.filter(p => p.state === "proposed").map(p => p.id);
     if (pendingIds.length < 2) return null;
     return (
       <Button
         variant="outlined"
         size="small"
         onClick={() => onApproveAll(pendingIds)}
         sx={{ alignSelf: "flex-start", mb: 0.5 }}
       >
         Approve All ({pendingIds.length})
       </Button>
     );
   }
   ```

6. **Action handlers:**

   ```typescript
   const handleApprove = useCallback(async (proposalId: string) => {
     // Optimistic update: set state to executing immediately
     setProposals(prev => {
       const next = new Map(prev);
       const existing = next.get(proposalId);
       if (existing) next.set(proposalId, { ...existing, state: "executing" as ActionState, updatedAt: new Date().toISOString() });
       return next;
     });
     try {
       const res = await approveAction(proposalId);
       setProposals(prev => new Map(prev).set(proposalId, res.proposal));
     } catch (error) {
       // Revert to proposed on failure or show error
       setProposals(prev => {
         const next = new Map(prev);
         const existing = next.get(proposalId);
         if (existing) next.set(proposalId, { ...existing, state: "failed" as ActionState, error: error instanceof Error ? error.message : "Approve failed" });
         return next;
       });
     }
   }, []);

   const handleDecline = useCallback(async (proposalId: string) => {
     setProposals(prev => {
       const next = new Map(prev);
       const existing = next.get(proposalId);
       if (existing) next.set(proposalId, { ...existing, state: "declined" as ActionState, updatedAt: new Date().toISOString() });
       return next;
     });
     try {
       await declineAction(proposalId);
     } catch { /* decline is best-effort */ }
   }, []);

   const handleRetry = useCallback(async (proposalId: string) => {
     setProposals(prev => {
       const next = new Map(prev);
       const existing = next.get(proposalId);
       if (existing) next.set(proposalId, { ...existing, state: "executing" as ActionState, updatedAt: new Date().toISOString() });
       return next;
     });
     try {
       const res = await retryAction(proposalId);
       setProposals(prev => new Map(prev).set(proposalId, res.proposal));
     } catch (error) {
       setProposals(prev => {
         const next = new Map(prev);
         const existing = next.get(proposalId);
         if (existing) next.set(proposalId, { ...existing, state: "failed" as ActionState, error: error instanceof Error ? error.message : "Retry failed" });
         return next;
       });
     }
   }, []);
   ```

7. **Approve All with sequential execution** (per user decision: "Approved actions execute sequentially, one at a time" and "If one fails mid-sequence: halt, keep remaining pending"):

   ```typescript
   const handleApproveAll = useCallback(async (proposalIds: string[]) => {
     for (const id of proposalIds) {
       // Check if any previous action failed — halt if so
       const current = proposals.get(id);
       if (!current || current.state !== "proposed") continue;

       await handleApprove(id);

       // After approve completes, check if it failed
       // We need to read the latest state — use a ref or read from the proposals map
       // Since handleApprove updates the map, we can check after await
       // But due to React batching, we need a small delay or use a ref pattern
       // Simplest: check the API response in handleApprove and abort if failed
     }
   }, [proposals, handleApprove]);
   ```

   For the sequential halt-on-failure behavior, modify handleApprove to return a success boolean, then in handleApproveAll:
   ```typescript
   const handleApproveAll = useCallback(async (proposalIds: string[]) => {
     for (const id of proposalIds) {
       const success = await handleApproveWithResult(id);
       if (!success) break; // Halt: keep remaining pending
     }
   }, []);
   ```

   Adjust `handleApproveWithResult` to return `true` on success, `false` on failure.

8. **Wire proposals to messages:**

   When rendering messages, look up proposals for each assistant message by matching `messageId`:

   ```typescript
   {messages.map(msg => {
     const msgProposals = msg.role === "assistant"
       ? Array.from(proposals.values()).filter(p => p.messageId === msg.id)
       : [];
     return msg.role === "user"
       ? <UserMessage key={msg.id} content={msg.content} />
       : <AssistantMessage
           key={msg.id}
           content={msg.content}
           toolCalls={msg.toolCalls}
           proposals={msgProposals}
           onApprove={handleApprove}
           onDecline={handleDecline}
           onRetry={handleRetry}
         />;
   })}
   ```

9. **Also handle proposals in StreamingMessage:**

   While streaming, proposals can arrive. Add proposals prop to StreamingMessage and render any proposals that have been received during the current stream:

   ```typescript
   {streaming && (
     <StreamingMessage
       content={streamContent}
       tools={activeTools}
       proposals={Array.from(proposals.values()).filter(p => /* belongs to current streaming message */)}
       onApprove={handleApprove}
       onDecline={handleDecline}
       onRetry={handleRetry}
     />
   )}
   ```

   To track which proposals belong to the current streaming message, generate the assistant message ID early (before streaming starts) and use it as the filter.

**Import additions:**
- Import `ApprovalCard` from `../components/ApprovalCard`
- Import `approveAction`, `declineAction`, `retryAction`, `getConversationProposals` from `../api`
- Import `ActionProposal`, `ActionState` from `@linearapp/shared`
- Import `Button` from `@mui/material` (for Approve All)
  </action>
  <verify>
1. Run `cd apps/web && npx tsc --noEmit` — no type errors
2. Start full dev stack (`npm run dev`)
3. Open chat and ask the agent to "Create an issue called Test Bug with high priority"
4. Verify:
   - An approval card appears inline in the agent's message with diff-style preview (Title: Test Bug, Priority: High)
   - Approve button is primary/filled, Decline is text/secondary
   - Click Approve → card shows spinner/executing → collapses to success line
   - Refresh the page → proposals reload and show correct state (succeeded, compact)
5. Test decline: Ask for another issue, click Decline → card shows declined state, agent acknowledges
6. Test failure: (If possible, break the demo handler temporarily) → card shows red error with Retry button → click Retry → executes again
7. Test multiple actions: Ask the agent to create 2 issues → two cards appear → Approve All button is visible → click it → they execute sequentially
  </verify>
  <done>
Approval cards render inline in assistant messages with diff-style preview. Approve/Decline/Retry buttons work correctly. Approve All shortcut appears for 2+ pending actions and executes sequentially. Failed actions halt the sequence and keep remaining pending. State persists across page refresh. Smooth animations between lifecycle states. The full end-to-end approval flow works from proposal to execution to result display.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: End-to-end approval flow verification</name>
  <files>apps/web/src/pages/ChatPage.tsx</files>
  <action>
This is a human verification checkpoint. No code changes — verify the complete approval flow works end-to-end.

What was built: Complete approval infrastructure and UI: action state machine with idempotency, SSE streaming refactor, tool registry with read/write classification, ApprovalManager service, approval card component with all lifecycle states, ChatPage integration with inline cards, approve/decline/retry endpoints, Approve All shortcut, and system prompt auto-generation.

How to verify:
1. Open the app at http://localhost:7923/chat
2. Start a new conversation and type: "Create an issue called Test Bug with high priority and assign to anyone"
3. Verify:
   - Agent responds with text AND an inline approval card
   - Card shows diff-style preview: Title: Test Bug, Priority: High, Assignee: [name]
   - Approve button is filled/colored, Decline is text/outline
4. Click Approve:
   - Card shows spinner + "Executing..."
   - Card collapses to compact success line (e.g., "Issue created: DEMO-123") with a link
5. Refresh the page (F5):
   - Navigate back to the same conversation
   - The succeeded card still shows as a compact success line (state persisted)
6. Start a new conversation, request another issue creation
7. Click Decline:
   - Card shows declined state (muted, compact)
   - Agent acknowledges naturally (no follow-up questions)
8. Request two issues at once (e.g., "Create two issues: Fix login bug and Update docs")
9. Verify:
   - Two separate cards appear, each with its own preview
   - "Approve All (2)" button appears above the cards
   - Click Approve All — cards execute one at a time
10. Double-click test: Request an issue, quickly double-click Approve
    - Only one execution should happen (idempotency check)
  </action>
  <verify>All 10 verification steps above pass without issues.</verify>
  <done>End-to-end approval flow verified by human: approve, decline, retry, Approve All, persistence across refresh, and idempotency all work correctly.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes from repo root
2. ApprovalCard component renders all 5 lifecycle states correctly
3. Cards appear inline within assistant messages (not as separate elements)
4. Approve button is primary/filled, Decline is secondary/text
5. Executing state shows spinner replacing buttons
6. Succeeded state collapses to compact single-line with link
7. Failed state shows red error with Retry button
8. Declined state shows muted compact line
9. Approve All appears when 2+ actions pending, executes sequentially
10. Failed action in sequence halts remaining, keeps them pending
11. State persists across page refresh (proposals load from server)
12. Double-click approve does not execute twice
13. Smooth animations between states (Collapse, Fade)
</verification>

<success_criteria>
- User can see inline approval cards with diff-style preview in chat
- User can approve, decline, and retry actions with one click
- Approve All works for bulk operations
- All lifecycle state transitions have visual feedback with smooth animations
- Action state persists across page refresh
- Double-click is prevented by UI disable + backend idempotency
- End-to-end flow: agent proposes -> user approves -> action executes -> result displayed
</success_criteria>

<output>
After completion, create `.planning/phases/01-approval-infrastructure-flow/01-03-SUMMARY.md`
</output>
